import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { Stack } from "expo-router";
import React, { useMemo, useState } from "react";
import { View, Text, StyleSheet, Modal, TextInput, Pressable, Platform, FlatList } from "react-native";
import { Calendar, LocaleConfig } from "react-native-calendars";
import DateTimePicker from "@react-native-community/datetimepicker";
import dayjs from "dayjs";
import { Ionicons } from "@expo/vector-icons";


type Lang = "pl" | "en";
const dict: Record<Lang, Record<string,string>> = {
  pl: { calendar:"Kalendarz", newEvent:"Nowe wydarzenie", title:"Tytuł", start:"Początek", end:"Koniec", cancel:"Anuluj", save:"Zapisz", upcoming:"Nadchodzące wydarzenia", empty:"Brak nadchodzących wydarzeń" },
  en: { calendar:"Calendar",  newEvent:"New event",       title:"Title", start:"Start",    end:"End",   cancel:"Cancel", save:"Save", upcoming:"Upcoming events", empty:"No upcoming events" }
};
const lang: Lang = "pl";
const t = (l:Lang, k:string) => (dict[l][k] ?? k);

// Locale (PL/EN)
LocaleConfig.locales.pl = {
  monthNames: ["Styczeń","Luty","Marzec","Kwiecień","Maj","Czerwiec","Lipiec","Sierpień","Wrzesień","Październik","Listopad","Grudzień"],
  monthNamesShort: ["Sty","Lut","Mar","Kwi","Maj","Cze","Lip","Sie","Wrz","Paź","Lis","Gru"],
  dayNames: ["Niedziela","Poniedziałek","Wtorek","Środa","Czwartek","Piątek","Sobota"],
  dayNamesShort: ["Nd","Pn","Wt","Śr","Czw","Pt","So"],
  today: "Dziś",
};
LocaleConfig.locales.en = {
  monthNames: ["January","February","March","April","May","June","July","August","September","October","November","December"],
  monthNamesShort: ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],
  dayNames: ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],
  dayNamesShort: ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],
  today: "Today",
};
LocaleConfig.defaultLocale = lang;

type EventItem = { id: string; title: string; startISO: string; endISO: string; };

export default function CalendarScreen() {
  const [selectedDate, setSelectedDate] = useState<string>(dayjs().format("YYYY-MM-DD"));
  const [events, setEvents] = useState<Record<string, EventItem[]>>({});

  // modal stanu
  const [modalVisible, setModalVisible] = useState(false);
  const [title, setTitle] = useState("");
  const [startTime, setStartTime] = useState<Date>(new Date());
  const [endTime, setEndTime] = useState<Date>(new Date());
  const [showStartPicker, setShowStartPicker] = useState(false);
  const [showEndPicker, setShowEndPicker] = useState(false);

  function openAdd(dateStr?: string) {
    const d = dateStr || selectedDate;
    setSelectedDate(d);
    const base = dayjs(d).toDate();
    const now = new Date();
    const st = new Date(base); st.setHours(now.getHours(), now.getMinutes(), 0, 0);
    const et = new Date(st); et.setMinutes(et.getMinutes() + 60);
    setTitle("");
    setStartTime(st);
    setEndTime(et);
    setModalVisible(true);
  }

  function saveEvent() {
    const d = selectedDate;
    if (!title.trim()) { setModalVisible(false); return; }
    const sISO = dayjs(d).hour(startTime.getHours()).minute(startTime.getMinutes()).second(0).millisecond(0).toISOString();
    const eISO = dayjs(d).hour(endTime.getHours()).minute(endTime.getMinutes()).second(0).millisecond(0).toISOString();
    const ev: EventItem = { id: String(Date.now()), title: title.trim(), startISO: sISO, endISO: eISO };
    setEvents(prev => {
      const list = prev[d] ? prev[d].slice() : [];
      list.push(ev);
      return { ...prev, [d]: list };
    });
    setModalVisible(false);
  }

  function removeEvent(id: string) {
    setEvents(prev => {
      const next: Record<string, EventItem[]> = {};
      Object.keys(prev).forEach((k) => {
        const left = prev[k].filter(e => e.id !== id);
        if (left.length) next[k] = left;
      });
      return next;
    });
  }

  // zaznaczenia w kalendarzu
  const marked: any = useMemo(() => {
    const m: any = {};
    if (selectedDate) m[selectedDate] = { selected: true, selectedColor: "#0A84FF" };
    Object.keys(events).forEach((d) => {
      if (!m[d]) m[d] = { marked: true };
      else m[d].marked = true;
    });
    return m;
  }, [selectedDate, events]);

  // lista nadchodzących (przyszłość, sort rosnąco)
  const upcoming: EventItem[] = useMemo(() => {
    const nowISO = new Date().toISOString();
    const arr: EventItem[] = [];
    Object.keys(events).forEach((d) => events[d].forEach((e) => { if (e.startISO >= nowISO) arr.push(e); }));
    arr.sort((a,b) => a.startISO.localeCompare(b.startISO));
    return arr;
  }, [events]);

  return (
    <View style={styles.screen}>
        <_CalendarTopSpacer />
      <Stack.Screen options={{ title: t(lang,"calendar") }} />

      {/* Kalendarz niżej */}
      <View style={[styles.card, { marginTop: 32 }]}>
        <Calendar
          current={selectedDate}
          onDayPress={(d) => { setSelectedDate(d.dateString); openAdd(d.dateString); }}
          markedDates={marked}
          style={styles.calendar}
          theme={{
            todayTextColor: "#0A84FF",
            selectedDayBackgroundColor: "#0A84FF",
          }}
        />
      </View>

      {/* Nadchodzące wydarzenia */}
      <Text style={styles.section}>{t(lang,"upcoming")}</Text>
      <FlatList scrollEnabled={false} bounces={false} alwaysBounceVertical={false} overScrollMode="never"
        contentContainerStyle={{ paddingHorizontal: 16, paddingBottom: 88 }}
        data={upcoming}
        keyExtractor={(it) => it.id}
        ListEmptyComponent={<Text style={styles.empty}>{t(lang,"empty")}</Text>}
        renderItem={({ item }) => (
          <View style={styles.eventCard}>
            <View style={{ flex: 1 }}>
              <Text style={styles.eventTitle}>{item.title}</Text>
              <Text style={styles.eventTime}>
                {dayjs(item.startISO).format("DD.MM.YYYY HH:mm")} – {dayjs(item.endISO).format("HH:mm")}
              </Text>
            </View>
            <Pressable onPress={() => removeEvent(item.id)} hitSlop={8} style={styles.trashBtn}>
              <Ionicons name="trash-outline" size={20} color="#EF4444" />
            </Pressable>
          </View>
        )}
      />

      {/* FAB + */}
      <Pressable style={styles.fab} onPress={() => openAdd()}>
        <Ionicons name="add" size={28} color="#fff" />
      </Pressable>

      {/* Modal dodawania */}
      <Modal visible={modalVisible} transparent animationType="slide">
        <View style={styles.modalBackdrop}>
          <View style={styles.modalCard}>
            <Text style={styles.modalTitle}>{t(lang,"newEvent")}</Text>
            <TextInput placeholder={t(lang,"title")} value={title} onChangeText={setTitle} style={styles.input} />
            <View style={styles.timeRow}>
              <Pressable style={styles.timeBtn} onPress={() => setShowStartPicker(true)}>
                <Text style={styles.timeLabel}>{t(lang,"start")}</Text>
                <Text style={styles.timeValue}>{dayjs(startTime).format("HH:mm")}</Text>
              </Pressable>
              <Pressable style={styles.timeBtn} onPress={() => setShowEndPicker(true)}>
                <Text style={styles.timeLabel}>{t(lang,"end")}</Text>
                <Text style={styles.timeValue}>{dayjs(endTime).format("HH:mm")}</Text>
              </Pressable>
            </View>

            {showStartPicker && (
              <DateTimePicker
                value={startTime}
                mode="time"
                is24Hour
                display={Platform.OS === "ios" ? "spinner" : "default"}
                onChange={(e, d) => { if (Platform.OS !== "ios") setShowStartPicker(false); if (d) setStartTime(d); }}
              />
            )}
            {showEndPicker && (
              <DateTimePicker
                value={endTime}
                mode="time"
                is24Hour
                display={Platform.OS === "ios" ? "spinner" : "default"}
                onChange={(e, d) => { if (Platform.OS !== "ios") setShowEndPicker(false); if (d) setEndTime(d); }}
              />
            )}

            <View style={styles.actions}>
              <Pressable style={[styles.btn, styles.btnSecondary]} onPress={() => setModalVisible(false)}>
                <Text style={styles.btnSecondaryText}>{t(lang,"cancel")}</Text>
              </Pressable>
              <Pressable style={[styles.btn, styles.btnPrimary]} onPress={saveEvent}>
                <Text style={styles.btnPrimaryText}>{t(lang,"save")}</Text>
              </Pressable>
            </View>
          </View>
        </View>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  screen: { flex: 1, backgroundColor: "#F4F7FA"},
  card: {
    marginHorizontal: 16,
    borderRadius: 16,
    backgroundColor: "#F4F7FA",
    padding: 8,
    shadowColor: "#000",
    shadowOpacity: 0.06,
    shadowRadius: 8,
    elevation: 2,
    alignSelf: "center",
    width: "92%",
  },
  calendar: { borderRadius: 16 },
  section: { marginTop: 12, marginHorizontal: 16, fontSize: 18, fontWeight: "700" },
  empty: { marginTop: 8, marginHorizontal: 16, color: "#6B7280" },
  eventCard: {
    marginTop: 8,
    backgroundColor: "#F4F7FA",
    borderRadius: 12,
    padding: 12,
    shadowColor: "#000",
    shadowOpacity: 0.05,
    shadowRadius: 6,
    elevation: 1,
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
  },
  eventTitle: { fontSize: 16, fontWeight: "600" },
  eventTime: { marginTop: 2, color: "#6B7280" },
  trashBtn: { padding: 6, borderRadius: 8, backgroundColor: "#FEE2E2" },

  fab: {
    position: "absolute",
    right: 20,
    bottom: 28,
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: "#0A84FF",
    alignItems: "center",
    justifyContent: "center",
    shadowColor: "#000",
    shadowOpacity: 0.15,
    shadowRadius: 8,
    elevation: 4,
  },

  modalBackdrop: { flex: 1, backgroundColor: "rgba(0,0,0,0.35)", padding: 16, justifyContent: "center" },
  modalCard: { backgroundColor: "#F4F7FA", borderRadius: 16, padding: 16 },
  modalTitle: { fontSize: 18, fontWeight: "700", marginBottom: 12 },
  input: {
    borderWidth: 1, borderColor: "#E1E8EF", borderRadius: 10,
    paddingHorizontal: 12, paddingVertical: 10, marginBottom: 12, backgroundColor: "#F4F7FA",
  },
  timeRow: { flexDirection: "row", gap: 12, marginBottom: 8 },
  timeBtn: { flex: 1, borderWidth: 1, borderColor: "#E1E8EF", borderRadius: 10, padding: 12, backgroundColor: "#F4F7FA" },
  timeLabel: { fontSize: 12, color: "#6B7280" },
  timeValue: { fontSize: 16, fontWeight: "600", marginTop: 2 },

  actions: { flexDirection: "row", justifyContent: "flex-end", gap: 12, marginTop: 12 },
  btn: { paddingVertical: 10, paddingHorizontal: 16, borderRadius: 10 },
  btnSecondary: { backgroundColor: "#F2F4F7" },
  btnSecondaryText: { color: "#111827", fontWeight: "600" },
  btnPrimary: { backgroundColor: "#0A84FF" },
  btnPrimaryText: { color: "#fff", fontWeight: "700" },
});

function _CalendarTopSpacer(){
  const insets = useSafeAreaInsets();
  const top = Math.max(Math.ceil(insets.top) + 32, 32);
  return <View style={{ height: top }} />;
}


