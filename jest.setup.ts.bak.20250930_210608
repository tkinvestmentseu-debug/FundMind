// eslint-disable
// @ts-nocheck

import "@testing-library/jest-native/extend-expect";

/** --- BRIDGE FIRST --- **/
(globalThis as any).__DEV__ = true;
(globalThis as any).__fbBatchedBridgeConfig = { remoteModuleConfig: [] };

/** Minimal native shims przed importem RN */
jest.mock("react-native/Libraries/BatchedBridge/NativeModules", () => ({
  I18nManager: { isRTL: false, doLeftAndRightSwapInRTL: false },
}));

jest.mock("react-native/Libraries/TurboModule/TurboModuleRegistry", () => {
  const UIManager = {
    getConstants: () => ({}),
    getViewManagerConfig: () => ({}),
    setLayoutAnimationEnabledExperimental: () => {},
    createView: () => {},
    updateView: () => {},
    dispatchViewManagerCommand: () => {},
    measure: () => {},
    measureInWindow: () => {},
    measureLayout: () => {},
  };
  const PlatformConstants = {
    getConstants: () => ({
      isTesting: true,
      reactNativeVersion: { major: 0, minor: 73, patch: 6 },
      interfaceIdiom: "handset",
      isHermes: false,
      osVersion: "test",
      systemName: "iOS",
    }),
  };
  const modules = { UIManager, PlatformConstants };
  return {
    get: (name) => modules[name],
    getEnforcing: (name) => {
      const mod = modules[name];
      if (!mod) throw new Error("TurboModule not found: " + name);
      return mod;
    },
  };
});/** Pomocniki RN często wyciszane w testach */
jest.mock("react-native/Libraries/Animated/NativeAnimatedHelper");

jest.mock("react-native/Libraries/Utilities/Dimensions", () => {
  const base = { width: 360, height: 640, scale: 2, fontScale: 1 };
  const listeners = new Set();
  return {
    get: jest.fn(() => ({ window: base, screen: base })),
    addEventListener: jest.fn((_t, fn) => { listeners.add(fn); return { remove: () => listeners.delete(fn) }; }),
    removeEventListener: jest.fn((_t, fn) => { listeners.delete(fn); }),
    set: jest.fn(),
  };
});

jest.mock("react-native/Libraries/Utilities/PixelRatio", () => ({
  get: () => 2,
  getFontScale: () => 1,
  roundToNearestPixel: (v) => Math.round(v),
  getPixelSizeForLayoutSize: (l) => Math.round(l * 2),
}));

/** Po przygotowaniu bridge i utils dopiero patchujemy publiczny moduł RN */
jest.mock("react-native", () => {
  const RN = jest.requireActual("react-native");
  const immediate = { start: (cb) => cb && cb(), stop: jest.fn(), reset: jest.fn() };
  if (RN.Animated) {
    RN.Animated.timing   = () => immediate;
    RN.Animated.spring   = () => immediate;
    RN.Animated.loop     = () => immediate;
    RN.Animated.sequence = () => immediate;
    RN.Animated.parallel = () => immediate;
    RN.Animated.stagger  = () => immediate;
    RN.Animated.delay    = () => immediate;
  }
  RN.InteractionManager = RN.InteractionManager || {};
  RN.InteractionManager.runAfterInteractions = (cb) => { cb && cb(); return Promise.resolve(); };

  RN.LayoutAnimation = RN.LayoutAnimation || {
    configureNext: jest.fn(),
    create: jest.fn(),
    Types: {}, Properties: {}, Presets: {},
  };

  RN.Appearance = RN.Appearance || {
    getColorScheme: () => "light",
    addChangeListener: jest.fn(),
    removeChangeListener: jest.fn(),
  };
  RN.useColorScheme = () => "light";

  return RN;
});

/** Wyciszenie nieistotnych warningów z act */
const _error = console.error;
beforeEach(() => {
  jest.useRealTimers();
  console.error = (...args) => {
    const msg = String(args[0] ?? "");
    if (msg.includes("not wrapped in act")) return;
    _error(...args);
  };
});
afterEach(() => { console.error = _error; });

